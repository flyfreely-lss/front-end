## 22.3 高级定时器

1. 使用 `setTimeout()` 和 `setInterval()` 创建的定时器可以用于实现有趣且有用的功能。

2. JavaScript是运行于单线程的环境中的。

3. 除了主JavaScript执行进程外，还有一个需要在进程下一次空闲时执行的代码队列。

4. 在JavaScript中没有任何代码是立刻执行的，但一旦进程空闲则尽快执行。

5. 定时器对队列的工作方式是，当特定时间过去后将代码插入。注意，给队列添加代码并不意味着对它立刻执行，而只能表示它会尽快执行。

6. 关于定时器要记住的最重要的事情是，指定的时间间隔表示何时将定时器的代码添加到队列，而不是何时实际执行代码。

### 22.3.1 重复的定时器

1. 当使用 `setInterval()` 时，仅当代码队列中没有该定时器的任何其他代码实例时，才将定时器代码添加到队列中。

2. 这种重复定时器的规则有2点问题：(1) 某些间隔会被跳过；(2) 多个定时器的代码执行之间的间隔可能会比预期的小。

3. 为了避免`setInterval()`的重复定时器的这2个缺点，你可以用如下模式使用链式setTimeout()调用。
```
setTimeout(function () {
  // 处理中

  setTimeout(arguments.callee, interval);

}, interval);
```

4. 每个浏览器窗口、标签页、或者框架都有其各自的代码执行队列。

### 22.3.2 Yielding Processes

1. 运行在浏览器中的JavaScript都被分配了一个确定数量的资源。

2. 脚本长时间运行的问题通常是由两个原因之一造成的：过长的、过深嵌套的函数调用或者是进行大量处理的循环。

3. 回答以下两个重要的问题:
* 该处理是否必须同步完成？
* 该处理是否必须同步完成？

当你发现某个循环占用了大量时间，同时对于上述两个问题，你的回答都是“否”，那么你就可以使用定时器分割这个循环。

4. 数组分块（array chunking）,基本的思路是为要处理的项目创建一个队列，然后使用定时器取出下一个要处理的项目进行处理，接着再设置另一个定时器。

5. 要实现数组分块非常简单，可以使用以下函数。
```
/*
* array：要处理的项目的数组
* process：用于处理项目的函数
* context：可选的运行该函数的环境
*/
function chunk(array, process, context) {
  setTimeout(function () {
    var item = array.shift();
    process.call(context, item);

    if (array.length > 0) {
      setTimeout(arguments.callee, 100);
    }
  }, 100);
}
```

6. 必须当心的地方是，传递给chunk()的数组是用作一个队列的，因此当处理数据的同时，数组中的条目也在改变。如果你想保持原数组不变，则应该将该数组的克隆传递给chunk()，如下例所示：
```
chunk(data.concat(), printValue);
```

7. 数组分块的重要性在于它可以将多个项目的处理在执行队列上分开，在每个项目处理之后，给予其他的浏览器处理机会运行，这样就可能避免长时间运行脚本的错误。

8. 一旦某个函数需要花50ms以上的时间完成，那么最好看看能否将任务分割为一系列可以使用定时器的小任务。

### 22.3.3 函数节流

1. 函数节流背后的基本思想是指，某些代码不可以在没有间断的情况连续重复执行。

2. 只要代码是周期性执行的，都应该使用节流，但是你不能控制请求执行的速率。

3. 代码实现举例
```
// 例如，假设有一个<div/>元素需要保持它的高度始终等同于宽度。那么实现这一功能的JavaScript可以如下编写：
window.resize = function () {
  var div = document.getElementById("myDiv");
  div.style.height = div.offsetWidth + "px";
};

// 节流实现：(如果100ms之内window.resize触发了共20次，resizeDiv()仍只会被调用一次。)
function throttle(method, context) {
  clearTimeout(method.tId);
  setTimeout(function () {
    method.call(context);
  }, 100);
}

function resizeDiv() {
  var div = document.getElementById("myDiv");
  div.style.height = div.offsetWidth + "px";
}

window.resize = function () {
  throttle(resizeDiv);
};

```

## 22.4 自定义事件

1. 事件是一种叫做观察者的设计模式，这是一种创建松散耦合代码的技术。

2. 观察者模式由两类对象组成：主体和观察者。主体负责发布事件，同时观察者通过订阅这些事件来观察该主体。

3. 自定义事件背后的概念是创建一个管理事件的对象，让其他对象监听那些事件。

4. 实现自定义事件的基本模式：
```
function EventTarget() {
  this.handles = {};
}

EventTarget.prototype = {
  constructor: EventTarget,
  // 用于注册给定类型事件的事件处理程序
  addHandler: function (type, handler) {
    if (typeof this.handles[type] == 'undefined') {
      this.handles[type] = [];
    }

    this.handles[type].push(handler);
  },

  // 用于触发一个事件
  fire: function (event) {
    if(!event.target) {
      event.target = this;
    }

    if (this.handles[event.type] instanceof Array) {
      var handlers = this.handles[event.type];
      for (var i = 0, len = handlers.length; i < len; i++) {
        handlers[i](event);
      }
    }
  },

  // 用于注销某个事件类型的事件处理程序
  removeHandler: function (type, handler) {
    if (this.handles[type] instanceof Array) {
      var handlers = this.handles[type];
      for (var i = 0, len = handlers.length; i < len; i++) {
        if (handlers[i] === handler) {
          break;
        }
      }

      this.handles[type].splice(i, 1);
    }
  }

};
```
使用：
```
//创建一个新对象
var target = new EventTarget();

//添加一个事件处理程
target.addHandler('message', handleMessage);

//触发事件
target.fire({type: 'message', message: 'Hello World!'});

//删除事件处理程序
target.removeHandler('message', handleMessage);

//再次，应没有处理程序
target.fire({type: 'message', message: 'Hello World!'});
```

5. 因为这种功能是封装在一种自定义类型中的，其他对象可以继承EventTarget并获得这个行为，如下例所示：
```
function Person(name, age) {
  EventTarget.call(this);
  this.name = name;
  this.age = age;
}

inheritPrototype(Person, EventTarget);

Person.prototype.say = function (message) {
  this.fire({type: "message", message: message});
};
```
使用：
```
function handleMessage(event) {
  alert(event.target.name + " says: " + event.message);
}

//创建新person
var person = new Person("Nicholas", 29);

//添加一个事件处理程序
person.addHandler("message", handleMessage);

//在该对象上调用1个方法，它触发消息事件
person.say("Hi there.");
```

6. 当代码中存在多个部分在特定时刻相互交互的情况下，自定义事件就非常有用了。这时，如果每个对象都有对其他所有对象的引用，那么整个代码就会紧密耦合，同时维护也变得很困难，因为对某个对象的修改也会影响到其他对象。使用自定义事件有助于解耦相关对象，保持功能的隔绝。在很多情况中，触发事件的代码和监听事件的代码是完全分离的。

## 22.5 拖放



## 22.6 小结

